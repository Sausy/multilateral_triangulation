// MKRVIDOR4000_peripherals_lite_sys_qspi.v

// This file was auto-generated from arduino_generic_qspi_controller2_hw.tcl.  If you edit it your changes
// will probably be lost.
// 
// Generated using ACDS version 18.1 625

`timescale 1 ps / 1 ps
module MKRVIDOR4000_peripherals_lite_sys_qspi #(
		parameter DEVICE_FAMILY     = "Cyclone 10 LP",
		parameter CS_WIDTH          = 3,
		parameter ADDR_WIDTH        = 19,
		parameter ASI_WIDTH         = 4,
		parameter ASMI_ADDR_WIDTH   = 24,
		parameter ENABLE_4BYTE_ADDR = 0,
		parameter IO_MODE           = "QUAD",
		parameter CHIP_SELS         = 1,
		parameter ATOM              = "UNIDIRECTIONAL"
	) (
		output wire        atom_ports_dclk,      //       atom_ports.dclk
		output wire        atom_ports_ncs,       //                 .ncs
		output wire        atom_ports_oe,        //                 .oe
		output wire [3:0]  atom_ports_dataout,   //                 .dataout
		output wire [3:0]  atom_ports_dataoe,    //                 .dataoe
		input  wire [3:0]  atom_ports_datain,    //                 .datain
		input  wire        avl_csr_read,         //          avl_csr.read
		output wire        avl_csr_waitrequest,  //                 .waitrequest
		input  wire        avl_csr_write,        //                 .write
		input  wire [3:0]  avl_csr_addr,         //                 .address
		input  wire [31:0] avl_csr_wrdata,       //                 .writedata
		output wire [31:0] avl_csr_rddata,       //                 .readdata
		output wire        avl_csr_rddata_valid, //                 .readdatavalid
		input  wire        avl_mem_write,        //          avl_mem.write
		input  wire [6:0]  avl_mem_burstcount,   //                 .burstcount
		output wire        avl_mem_waitrequest,  //                 .waitrequest
		input  wire        avl_mem_read,         //                 .read
		input  wire [18:0] avl_mem_addr,         //                 .address
		input  wire [31:0] avl_mem_wrdata,       //                 .writedata
		output wire [31:0] avl_mem_rddata,       //                 .readdata
		output wire        avl_mem_rddata_valid, //                 .readdatavalid
		input  wire [3:0]  avl_mem_byteenable,   //                 .byteenable
		output wire        irq,                  // interrupt_sender.irq
		input  wire        clk,                  //       clock_sink.clk
		input  wire        reset_n               //            reset.reset_n
	);

	wire  [31:0] addr_adaption_1_asmi_mem_readdata;       // asmi2_inst_qspi_ctrl:avl_mem_readdata -> addr_adaption_1:asmi_mem_rddata
	wire         addr_adaption_1_asmi_mem_waitrequest;    // asmi2_inst_qspi_ctrl:avl_mem_waitrequest -> addr_adaption_1:asmi_mem_waitrequest
	wire  [31:0] addr_adaption_1_asmi_mem_address;        // addr_adaption_1:asmi_mem_addr -> asmi2_inst_qspi_ctrl:avl_mem_address
	wire         addr_adaption_1_asmi_mem_read;           // addr_adaption_1:asmi_mem_read -> asmi2_inst_qspi_ctrl:avl_mem_read
	wire   [3:0] addr_adaption_1_asmi_mem_byteenable;     // addr_adaption_1:asmi_mem_byteenable -> asmi2_inst_qspi_ctrl:avl_mem_byteenable
	wire         addr_adaption_1_asmi_mem_readdatavalid;  // asmi2_inst_qspi_ctrl:avl_mem_readdatavalid -> addr_adaption_1:asmi_mem_rddata_valid
	wire         addr_adaption_1_asmi_mem_write;          // addr_adaption_1:asmi_mem_write -> asmi2_inst_qspi_ctrl:avl_mem_write
	wire  [31:0] addr_adaption_1_asmi_mem_writedata;      // addr_adaption_1:asmi_mem_wrdata -> asmi2_inst_qspi_ctrl:avl_mem_writedata
	wire   [6:0] addr_adaption_1_asmi_mem_burstcount;     // addr_adaption_1:asmi_mem_burstcount -> asmi2_inst_qspi_ctrl:avl_mem_burstcount
	wire  [31:0] addr_adaption_1_asmi_csr_readdata;       // asmi2_inst_qspi_ctrl:avl_csr_readdata -> addr_adaption_1:asmi_csr_rddata
	wire         addr_adaption_1_asmi_csr_waitrequest;    // asmi2_inst_qspi_ctrl:avl_csr_waitrequest -> addr_adaption_1:asmi_csr_waitrequest
	wire   [5:0] addr_adaption_1_asmi_csr_address;        // addr_adaption_1:asmi_csr_addr -> asmi2_inst_qspi_ctrl:avl_csr_address
	wire         addr_adaption_1_asmi_csr_read;           // addr_adaption_1:asmi_csr_read -> asmi2_inst_qspi_ctrl:avl_csr_read
	wire         addr_adaption_1_asmi_csr_readdatavalid;  // asmi2_inst_qspi_ctrl:avl_csr_readdatavalid -> addr_adaption_1:asmi_csr_rddata_valid
	wire         addr_adaption_1_asmi_csr_write;          // addr_adaption_1:asmi_csr_write -> asmi2_inst_qspi_ctrl:avl_csr_write
	wire  [31:0] addr_adaption_1_asmi_csr_writedata;      // addr_adaption_1:asmi_csr_wrdata -> asmi2_inst_qspi_ctrl:avl_csr_writedata
	wire   [3:0] addr_adaption_1_chip_select_chip_select; // addr_adaption_1:chip_select -> asmi2_inst_qspi_ctrl:chip_select_chip_select

	generate
		// If any of the display statements (or deliberately broken
		// instantiations) within this generate block triggers then this module
		// has been instantiated this module with a set of parameters different
		// from those it was generated for.  This will usually result in a
		// non-functioning system.
		if (DEVICE_FAMILY != "Cyclone 10 LP")
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					device_family_check ( .error(1'b1) );
		end
		if (CS_WIDTH != 3)
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					cs_width_check ( .error(1'b1) );
		end
		if (ADDR_WIDTH != 19)
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					addr_width_check ( .error(1'b1) );
		end
		if (ASI_WIDTH != 4)
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					asi_width_check ( .error(1'b1) );
		end
		if (ASMI_ADDR_WIDTH != 24)
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					asmi_addr_width_check ( .error(1'b1) );
		end
		if (ENABLE_4BYTE_ADDR != 0)
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					enable_4byte_addr_check ( .error(1'b1) );
		end
		if (IO_MODE != "QUAD")
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					io_mode_check ( .error(1'b1) );
		end
		if (CHIP_SELS != 1)
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					chip_sels_check ( .error(1'b1) );
		end
		if (ATOM != "UNIDIRECTIONAL")
		begin
			initial begin
				$display("Generated module instantiated with wrong parameters");
				$stop;
			end
			instantiated_with_wrong_parameters_error_see_comment_above
					atom_check ( .error(1'b1) );
		end
	endgenerate

	MKRVIDOR4000_peripherals_lite_sys_qspi_asmi2_inst_qspi_ctrl asmi2_inst_qspi_ctrl (
		.avl_csr_address         (addr_adaption_1_asmi_csr_address),        //     avl_csr.address
		.avl_csr_read            (addr_adaption_1_asmi_csr_read),           //            .read
		.avl_csr_readdata        (addr_adaption_1_asmi_csr_readdata),       //            .readdata
		.avl_csr_write           (addr_adaption_1_asmi_csr_write),          //            .write
		.avl_csr_writedata       (addr_adaption_1_asmi_csr_writedata),      //            .writedata
		.avl_csr_waitrequest     (addr_adaption_1_asmi_csr_waitrequest),    //            .waitrequest
		.avl_csr_readdatavalid   (addr_adaption_1_asmi_csr_readdatavalid),  //            .readdatavalid
		.avl_mem_address         (addr_adaption_1_asmi_mem_address),        //     avl_mem.address
		.avl_mem_read            (addr_adaption_1_asmi_mem_read),           //            .read
		.avl_mem_readdata        (addr_adaption_1_asmi_mem_readdata),       //            .readdata
		.avl_mem_write           (addr_adaption_1_asmi_mem_write),          //            .write
		.avl_mem_writedata       (addr_adaption_1_asmi_mem_writedata),      //            .writedata
		.avl_mem_byteenable      (addr_adaption_1_asmi_mem_byteenable),     //            .byteenable
		.avl_mem_burstcount      (addr_adaption_1_asmi_mem_burstcount),     //            .burstcount
		.avl_mem_waitrequest     (addr_adaption_1_asmi_mem_waitrequest),    //            .waitrequest
		.avl_mem_readdatavalid   (addr_adaption_1_asmi_mem_readdatavalid),  //            .readdatavalid
		.clk_clk                 (clk),                                     //         clk.clk
		.reset_reset             (~reset_n),                                //       reset.reset
		.chip_select_chip_select (addr_adaption_1_chip_select_chip_select), // chip_select.chip_select
		.atom_ports_dclk         (atom_ports_dclk),                         //  atom_ports.dclk
		.atom_ports_ncs          (atom_ports_ncs),                          //            .ncs
		.atom_ports_oe           (atom_ports_oe),                           //            .oe
		.atom_ports_dataout      (atom_ports_dataout),                      //            .dataout
		.atom_ports_dataoe       (atom_ports_dataoe),                       //            .dataoe
		.atom_ports_datain       (atom_ports_datain)                        //            .datain
	);

	altera_qspi_address_adaption #(
		.DEVICE_FAMILY     ("Cyclone 10 LP"),
		.ADDR_WIDTH        (19),
		.ASMI_ADDR_WIDTH   (24),
		.ASI_WIDTH         (4),
		.CS_WIDTH          (3),
		.CHIP_SELS         (1),
		.ENABLE_4BYTE_ADDR (0)
	) addr_adaption_1 (
		.clk                   (clk),                                     //       clock_sink.clk
		.reset                 (~reset_n),                                //            reset.reset
		.avl_csr_read          (avl_csr_read),                            //          avl_csr.read
		.avl_csr_waitrequest   (avl_csr_waitrequest),                     //                 .waitrequest
		.avl_csr_write         (avl_csr_write),                           //                 .write
		.avl_csr_addr          (avl_csr_addr),                            //                 .address
		.avl_csr_wrdata        (avl_csr_wrdata),                          //                 .writedata
		.avl_csr_rddata        (avl_csr_rddata),                          //                 .readdata
		.avl_csr_rddata_valid  (avl_csr_rddata_valid),                    //                 .readdatavalid
		.asmi_csr_addr         (addr_adaption_1_asmi_csr_address),        //         asmi_csr.address
		.asmi_csr_read         (addr_adaption_1_asmi_csr_read),           //                 .read
		.asmi_csr_rddata       (addr_adaption_1_asmi_csr_readdata),       //                 .readdata
		.asmi_csr_write        (addr_adaption_1_asmi_csr_write),          //                 .write
		.asmi_csr_wrdata       (addr_adaption_1_asmi_csr_writedata),      //                 .writedata
		.asmi_csr_waitrequest  (addr_adaption_1_asmi_csr_waitrequest),    //                 .waitrequest
		.asmi_csr_rddata_valid (addr_adaption_1_asmi_csr_readdatavalid),  //                 .readdatavalid
		.avl_mem_write         (avl_mem_write),                           //          avl_mem.write
		.avl_mem_burstcount    (avl_mem_burstcount),                      //                 .burstcount
		.avl_mem_waitrequest   (avl_mem_waitrequest),                     //                 .waitrequest
		.avl_mem_read          (avl_mem_read),                            //                 .read
		.avl_mem_addr          (avl_mem_addr),                            //                 .address
		.avl_mem_wrdata        (avl_mem_wrdata),                          //                 .writedata
		.avl_mem_rddata        (avl_mem_rddata),                          //                 .readdata
		.avl_mem_rddata_valid  (avl_mem_rddata_valid),                    //                 .readdatavalid
		.avl_mem_byteenable    (avl_mem_byteenable),                      //                 .byteenable
		.asmi_mem_addr         (addr_adaption_1_asmi_mem_address),        //         asmi_mem.address
		.asmi_mem_read         (addr_adaption_1_asmi_mem_read),           //                 .read
		.asmi_mem_rddata       (addr_adaption_1_asmi_mem_readdata),       //                 .readdata
		.asmi_mem_write        (addr_adaption_1_asmi_mem_write),          //                 .write
		.asmi_mem_wrdata       (addr_adaption_1_asmi_mem_writedata),      //                 .writedata
		.asmi_mem_byteenable   (addr_adaption_1_asmi_mem_byteenable),     //                 .byteenable
		.asmi_mem_burstcount   (addr_adaption_1_asmi_mem_burstcount),     //                 .burstcount
		.asmi_mem_waitrequest  (addr_adaption_1_asmi_mem_waitrequest),    //                 .waitrequest
		.asmi_mem_rddata_valid (addr_adaption_1_asmi_mem_readdatavalid),  //                 .readdatavalid
		.irq                   (irq),                                     // interrupt_sender.irq
		.chip_select           (addr_adaption_1_chip_select_chip_select)  //      chip_select.chip_select
	);

endmodule
