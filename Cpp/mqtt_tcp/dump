/* SPI Master example
   This example code is in the Public Domain (or CC0 licensed, at your option.)
   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
//#include "esp_system.h"
#include "driver/spi_master.h"
//#include "soc/gpio_struct.h"
//#include "driver/gpio.h"


#define PIN_NUM_MISO 25
#define PIN_NUM_MOSI 23
#define PIN_NUM_CLK  19
#define PIN_NUM_CS   22
#define PIN_NUM_WP   -1
#define PIN_NUM_HD   -1

#define ALTERA_IDLE_CHAR 0x4a


int spi_command(unsigned int base, unsigned int slave,
                unsigned int write_length, const unsigned char * write_data,
                unsigned int read_length, unsigned char * read_data,
                unsigned int flags){
    //base will be unused ....

    esp_err_t ret;
    spi_transaction_t t;

    memset(&t, 0, sizeof(t));       //Zero out the transaction

    t.length=write_length;                 //Len is in bytes, transaction length is in bits.
    t.rxlength=read_length;
    t.tx_buffer=write_data;               //Data
    t.rx_buffer=read_data;
    t.user=(void*)1;                //D/C needs to be set to 1


    ret=spi_device_polling_transmit(spi, &t);  //Transmit!
    assert(ret==ESP_OK);
}

void app_main()
{
    esp_err_t ret;
    spi_device_handle_t spi;
    spi_bus_config_t buscfg={PIN_NUM_MOSI,PIN_NUM_MISO,PIN_NUM_CLK,PIN_NUM_WP,PIN_NUM_HD} //.max_transfer_sz=PARALLEL_LINES*320*2+8  <= could be added

    /*
    int mosi_io_num;                ///< GPIO pin for Master Out Slave In (=spi_d) signal, or -1 if not used.
    int miso_io_num;                ///< GPIO pin for Master In Slave Out (=spi_q) signal, or -1 if not used.
    int sclk_io_num;                ///< GPIO pin for Spi CLocK signal, or -1 if not used.
    int quadwp_io_num;              ///< GPIO pin for WP (Write Protect) signal which is used as D2 in 4-bit communication modes, or -1 if not used.
    int quadhd_io_num;              ///< GPIO pin for HD (HolD) signal which is used as D3 in 4-bit communication modes, or -1 if not used.
    int max_transfer_sz;            ///< Maximum transfer size, in bytes. Defaults to 4094 if 0.
    uint32_t flags;                 ///< Abilities of bus to be checked by the driver. Or-ed value of ``SPICOMMON_BUSFLAG_*`` flags.
    int intr_flags
    */


    spi_device_interface_config_t devcfg={
      0,  //< Amount of bits in command phase (0-16)
      0,  //< Amount of bits in address phase (0-64)
      0,  //< Amount of dummy bits to insert between address and data phase
      0,  //< SPI mode (0-3)
      0,  //< Duty cycle of positive clock, in 1/256th increments (128 = 50%/50% duty). Setting this to 0 (=not setting it) is equivalent to setting this to 128.
      0,  //< Amount of SPI bit-cycles the cs should be activated before the transmission (0-16). This only works on half-duplex transactions.
      0,  //< Amount of SPI bit-cycles the cs should stay active after the transmission (0-16)
      26*1000*1000,    //< Clock speed, in Hz
      PIN_NUM_CS    //< CS GPIO pin for this device, or -1 if not used
      0    //< Bitwise OR of SPI_DEVICE_* flags
      7    //< Transaction queue size. This sets how many transactions can be 'in the air' (queued using spi_device_queue_trans but not yet finished using spi_device_get_trans_result) at the same time
          //< Callback to be called before a transmission is started. This callback is called within interrupt context.
      };

    //Initialize the SPI bus
    ret=spi_bus_initialize(HSPI_HOST, &buscfg, 1);
    ESP_ERROR_CHECK(ret);


    ret=spi_bus_add_device(HSPI_HOST, &devcfg, &spi);
    ESP_ERROR_CHECK(ret);


}
